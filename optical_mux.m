
% muxV2 模拟光学多路复用/解复用和超高斯滤波过程
function [yt, Ndelay] = optical_mux(B3, N, t0, xt)

% 输入参数说明
% B3: 光学3 dB带宽，决定了滤波器的通带宽度
% N: 滤波器的阶数，可以是1、2或3，影响滤波器的陡峭程度
% t0: 采样间隔，与信号的采样频率相关
% xt: 输入信号，即光场强度E

% 输出参数说明
% yt: 经过滤波处理后的输出信号
% Ndelay: 滤波器引入的时间延迟，以样本数表示

% 根据滤波器阶数和带宽估计脉冲响应长度，以便使用FFT
if N == 1
  N_zp = 2*ceil(1/(t0*B3)); % 滤波器阶数为1时的零填充数量
elseif N == 2
  N_zp = 5*ceil(1/(t0*B3)); % 滤波器阶数为2时的零填充数量
elseif N == 3
  N_zp = 10*ceil(1/(t0*B3)); % 滤波器阶数为3时的零填充数量
end

% 对输入信号进行零填充，以避免FFT的边界效应(滤波器delay码元)
xt = [zeros(N_zp, 1); xt; zeros(N_zp, 1)];

% 计算FFT的大小，并确保它是偶数，如果需要，添加额外的零
Nfft = length(xt);
if mod(Nfft, 2)
  Nfft = Nfft+1;
  xt = [xt; 0]; % 如果FFT大小为奇数，添加一个零使其变为偶数
end

% 计算FFT的时间周期和频率分辨率
tp = Nfft*t0; % FFT的时间周期
f0 = 1/tp; % 频率分辨率
f = f0*[-Nfft/2:Nfft/2-1]'; % 频率向量

% 定义超高斯滤波器的频率响应
% 超高斯滤波器的形状由滤波器阶数N和带宽B3决定
Gf = fftshift( exp( -log(2) * (2*f/B3).^(2*N) / 2) );

% 对输入信号进行滤波处理
% 首先对信号进行FFT，然后与滤波器的频率响应相乘，最后进行IFFT
yt = ifft( fft(xt).*Gf );

% 计算滤波器引入的时间延迟
% 由于零填充，滤波器的脉冲响应在N_zp个零样本后开始
Ndelay = N_zp;

% 函数定义结束
end
% ```

% 通过在频域中应用一个超高斯滤波器来模拟信号的光学滤波过程。它首先对输入信号进行零填充。
% 然后计算滤波器的频率响应，并将其应用于信号。
% 返回滤波后的信号和滤波器引入的时间延迟。
% 模拟信号在实际光学滤波器中的行为。